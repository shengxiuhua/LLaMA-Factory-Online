
## 4. Epochs 与 Overfitting (过拟合)

### 4.1 训练轮数的选择策略

训练轮数（Epochs）的选择需要在充分学习和避免过拟合之间找到平衡。在大模型微调中，由于模型容量大而训练数据相对较少，过拟合是一个常见问题。

**过拟合的表现**：训练损失持续下降，但验证损失开始上升；训练准确率很高，但验证准确率停滞或下降；模型在训练集上表现完美，但在测试集上表现不佳。

**早停策略**：监控验证集性能，当验证性能不再提升时停止训练。

**学习率衰减**：在训练后期降低学习率，进行精细调整。

```python
import numpy as np
import matplotlib.pyplot as plt
from collections import deque

class EarlyStopping:
    """早停机制"""
    
    def __init__(self, patience=7, min_delta=0, restore_best_weights=True):
        self.patience = patience
        self.min_delta = min_delta
        self.restore_best_weights = restore_best_weights
        self.best_loss = None
        self.counter = 0
        self.best_weights = None
        
    def __call__(self, val_loss, model):
        if self.best_loss is None:
            self.best_loss = val_loss
            self.save_checkpoint(model)
        elif val_loss < self.best_loss - self.min_delta:
            self.best_loss = val_loss
            self.counter = 0
            self.save_checkpoint(model)
        else:
            self.counter += 1
            
        if self.counter >= self.patience:
            if self.restore_best_weights:
                model.load_state_dict(self.best_weights)
            return True
        return False
    
    def save_checkpoint(self, model):
        """保存最佳权重"""
        self.best_weights = model.state_dict().copy()

class OverfittingDetector:
    """过拟合检测器"""
    
    def __init__(self, window_size=5, threshold=0.1):
        self.window_size = window_size
        self.threshold = threshold
        self.train_losses = deque(maxlen=window_size)
        self.val_losses = deque(maxlen=window_size)
        
    def update(self, train_loss, val_loss):
        """更新损失历史"""
        self.train_losses.append(train_loss)
        self.val_losses.append(val_loss)
        
    def is_overfitting(self):
        """检测是否过拟合"""
        if len(self.train_losses) < self.window_size:
            return False
            
        # 计算训练损失和验证损失的趋势
        train_trend = np.polyfit(range(self.window_size), list(self.train_losses), 1)[0]
        val_trend = np.polyfit(range(self.window_size), list(self.val_losses), 1)[0]
        
        # 训练损失下降但验证损失上升
        if train_trend < -self.threshold and val_trend > self.threshold:
            return True
            
        # 验证损失显著高于训练损失
        recent_train_loss = np.mean(list(self.train_losses)[-3:])
        recent_val_loss = np.mean(list(self.val_losses)[-3:])
        
        if recent_val_loss > recent_train_loss * 1.5:
            return True
            
        return False
    
    def get_overfitting_score(self):
        """获取过拟合程度评分"""
        if len(self.train_losses) < self.window_size:
            return 0.0
            
        recent_train_loss = np.mean(list(self.train_losses)[-3:])
        recent_val_loss = np.mean(list(self.val_losses)[-3:])
        
        # 计算过拟合评分
        if recent_train_loss > 0:
            overfitting_score = max(0, (recent_val_loss - recent_train_loss) / recent_train_loss)
        else:
            overfitting_score = 0.0
            
        return min(1.0, overfitting_score)

def recommend_epochs(dataset_size, model_size, task_complexity='medium'):
    """推荐训练轮数"""
    
    # 基础轮数推荐
    base_epochs = {
        'simple': {'small': 5, 'medium': 3, 'large': 2},
        'medium': {'small': 8, 'medium': 5, 'large': 3},
        'complex': {'small': 12, 'medium': 8, 'large': 5}
    }
    
    # 根据数据集大小调整
    if dataset_size < 1000:
        size_factor = 1.5  # 小数据集需要更多轮数
    elif dataset_size < 10000:
        size_factor = 1.0
    else:
        size_factor = 0.8  # 大数据集可以减少轮数
    
    # 确定模型大小类别
    if '1b' in model_size or '3b' in model_size:
        model_category = 'small'
    elif '7b' in model_size or '13b' in model_size:
        model_category = 'medium'
    else:
        model_category = 'large'
    
    recommended_epochs = int(base_epochs[task_complexity][model_category] * size_factor)
    
    return {
        'recommended_epochs': recommended_epochs,
        'min_epochs': max(1, recommended_epochs - 2),
        'max_epochs': recommended_epochs + 3,
        'early_stopping_patience': max(2, recommended_epochs // 3),
        'lr_decay_start': max(1, recommended_epochs // 2)
    }

def simulate_training_curves():
    """模拟训练曲线以演示过拟合检测"""
    
    # 模拟不同的训练场景
    scenarios = {
        'normal': {
            'train_losses': [2.0, 1.5, 1.2, 1.0, 0.9, 0.85, 0.82, 0.80, 0.79, 0.78],
            'val_losses': [2.1, 1.6, 1.3, 1.1, 1.0, 0.95, 0.93, 0.92, 0.91, 0.90]
        },
        'overfitting': {
            'train_losses': [2.0, 1.5, 1.0, 0.7, 0.5, 0.3, 0.2, 0.1, 0.05, 0.02],
            'val_losses': [2.1, 1.6, 1.2, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7]
        },
        'underfitting': {
            'train_losses': [2.0, 1.9, 1.8, 1.75, 1.7, 1.68, 1.66, 1.65, 1.64, 1.63],
            'val_losses': [2.1, 2.0, 1.9, 1.85, 1.8, 1.78, 1.76, 1.75, 1.74, 1.73]
        }
    }
    
    plt.figure(figsize=(15, 5))
    
    for i, (scenario_name, losses) in enumerate(scenarios.items()):
        plt.subplot(1, 3, i+1)
        
        epochs = range(1, len(losses['train_losses']) + 1)
        plt.plot(epochs, losses['train_losses'], 'b-', label='训练损失')
        plt.plot(epochs, losses['val_losses'], 'r-', label='验证损失')
        
        plt.xlabel('Epochs')
        plt.ylabel('Loss')
        plt.title(f'{scenario_name.capitalize()} Training')
        plt.legend()
        plt.grid(True)
        
        # 使用过拟合检测器
        detector = OverfittingDetector()
        for epoch in range(len(losses['train_losses'])):
            detector.update(losses['train_losses'][epoch], losses['val_losses'][epoch])
            
            if epoch >= 4:  # 至少需要5个数据点
                if detector.is_overfitting():
                    plt.axvline(x=epoch+1, color='orange', linestyle='--', alpha=0.7)
                    plt.text(epoch+1, max(losses['val_losses']), 'Overfitting\nDetected', 
                            rotation=90, verticalalignment='top')
                    break
    
    plt.tight_layout()
    plt.show()

# 使用示例
print("=== 训练轮数推荐 ===")
datasets = [500, 2000, 10000]
models = ['7b', '13b', '30b']
complexities = ['simple', 'medium', 'complex']

for dataset_size in datasets:
    for model_size in models:
        for complexity in complexities:
            recommendation = recommend_epochs(dataset_size, model_size, complexity)
            print(f"数据集{dataset_size}, {model_size}模型, {complexity}任务: "
                  f"{recommendation['recommended_epochs']} epochs "
                  f"(范围: {recommendation['min_epochs']}-{recommendation['max_epochs']})")

print("\n=== 过拟合检测演示 ===")
simulate_training_curves()
```

